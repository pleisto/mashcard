# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/action_policy/all/action_policy.rbi
#
# action_policy-0.6.0

module ActionPolicy
  def self.cache_store; end
  def self.cache_store=(arg0); end
  def self.enforce_predicate_rules_naming; end
  def self.enforce_predicate_rules_naming=(arg0); end
  def self.lookup(target, allow_nil: nil, default: nil, **options); end
end
module ActionPolicy::Ext
end
module ActionPolicy::Ext::PolicyCacheKey
end
module ActionPolicy::Ext::PolicyCacheKey::ObjectExt
  def _policy_cache_key(use_object_id: nil); end
end
module ActionPolicy::Behaviours
end
module ActionPolicy::Behaviours::PolicyFor
  def authorization_context; end
  def authorization_namespace; end
  def authorization_strict_namespace; end
  def default_authorization_policy_class; end
  def implicit_authorization_target!; end
  def implicit_authorization_target; end
  def policy_for(record:, with: nil, namespace: nil, context: nil, allow_nil: nil, default: nil, strict_namespace: nil); end
  def policy_for_cache_key(record:, with: nil, namespace: nil, context: nil, **arg4); end
end
module ActionPolicy::Policy
end
class ActionPolicy::Policy::ExecutionResult
  def cached!; end
  def cached?; end
  def fail?; end
  def initialize(policy, rule); end
  def inspect; end
  def load(value); end
  def policy; end
  def rule; end
  def success?; end
  def value; end
end
module ActionPolicy::SuggestMessage
  def suggest(needle, heystack); end
end
module ActionPolicy::PrettyPrint
  def self.available?; end
  def self.colorize(val); end
  def self.ignore_expressions; end
  def self.ignore_expressions=(arg0); end
  def self.print_method(object, method_name); end
end
class ActionPolicy::PrettyPrint::Visitor
  def collect(ast); end
  def eval_exp(exp); end
  def expression_with_result(sexp); end
  def ignore_exp?(exp); end
  def indent; end
  def indent=(arg0); end
  def indented(str); end
  def initialize(object); end
  def lines; end
  def object; end
  def visit_and(ast); end
  def visit_begin(ast); end
  def visit_missing(ast); end
  def visit_node(ast); end
  def visit_or(ast); end
end
class ActionPolicy::UnknownRule < ActionPolicy::Error
  def initialize(policy, rule); end
  def message; end
  def policy; end
  def rule; end
  include ActionPolicy::SuggestMessage
end
class ActionPolicy::NonPredicateRule < ActionPolicy::UnknownRule
  def initialize(policy, rule); end
end
module ActionPolicy::Policy::Core
  def __apply__(rule); end
  def allow!; end
  def allowed_to?(rule, record = nil, **options); end
  def apply(rule); end
  def check?(*args, **hargs); end
  def deny!; end
  def initialize(record = nil, *arg1); end
  def inspect_rule(rule); end
  def pp(rule); end
  def record; end
  def resolve_rule(activity); end
  def result; end
  def self.included(base); end
  def with_clean_result; end
  include ActionPolicy::Behaviours::PolicyFor
end
module ActionPolicy::Policy::Core::ClassMethods
  def identifier; end
  def identifier=(arg0); end
  def result_class; end
end
module ActionPolicy::Policy::Defaults
  def create?; end
  def index?; end
  def manage?; end
  def self.included(base); end
end
class ActionPolicy::AuthorizationContextMissing < ActionPolicy::Error
  def initialize(id); end
  def message; end
end
module ActionPolicy::Policy::Authorization
  def authorization_context; end
  def initialize(record = nil, **params); end
  def self.included(base); end
end
module ActionPolicy::Policy::Authorization::ClassMethods
  def authorization_targets; end
  def authorize(*ids, allow_nil: nil, optional: nil); end
end
class ActionPolicy::Policy::FailureReasons
  def add(policy_or_class, rule, details = nil); end
  def add_detailed_reason(store, detailed_rule); end
  def add_non_detailed_reason(store, rule); end
  def details; end
  def empty?; end
  def initialize; end
  def merge(other); end
  def present?; end
  def reasons; end
  def with_details(rule, details); end
end
module ActionPolicy::Policy::ResultFailureReasons
  def all_details; end
  def clear_details; end
  def details; end
  def details=(arg0); end
  def inspect; end
  def reasons; end
end
module ActionPolicy::Policy::Reasons
  def allowed_to?(rule, record = nil, inline_reasons: nil, **options); end
  def deny!(reason = nil); end
  def details; end
  def self.included(base); end
end
module ActionPolicy::Policy::PreCheck
  def __apply__(rule); end
  def run_pre_checks(rule); end
  def self.included(base); end
end
class ActionPolicy::Policy::PreCheck::Check
  def applicable?(rule); end
  def blacklist; end
  def call(policy); end
  def dup; end
  def filter; end
  def initialize(policy, name, except: nil, only: nil); end
  def name; end
  def policy_class; end
  def rebuild_filter; end
  def skip!(except: nil, only: nil); end
  def whitelist; end
end
module ActionPolicy::Policy::PreCheck::ClassMethods
  def pre_check(*names, **options); end
  def pre_checks; end
  def skip_pre_check(*names, **options); end
end
module ActionPolicy::Policy::Aliases
  def check_rule_naming(activity); end
  def resolve_rule(activity); end
  def self.included(base); end
end
module ActionPolicy::Policy::Aliases::ClassMethods
  def alias_rule(*rules, to:); end
  def default_rule(val); end
  def lookup_alias(rule); end
  def lookup_default_rule; end
  def method_added(name); end
  def rules_aliases; end
end
module ActionPolicy::Behaviours::Scoping
  def authorization_scope_type_for(policy, target); end
  def authorized(target, type: nil, as: nil, scope_options: nil, **options); end
  def authorized_scope(target, type: nil, as: nil, scope_options: nil, **options); end
end
class ActionPolicy::UnknownScopeType < ActionPolicy::Error
  def initialize(policy_class, type); end
  def message; end
  include ActionPolicy::SuggestMessage
end
class ActionPolicy::UnknownNamedScope < ActionPolicy::Error
  def initialize(policy_class, type, name); end
  def message; end
  include ActionPolicy::SuggestMessage
end
class ActionPolicy::UnrecognizedScopeTarget < ActionPolicy::Error
  def initialize(target); end
  def message; end
end
module ActionPolicy::Policy::Scoping
  def apply_scope(target, type:, name: nil, scope_options: nil); end
  def lookup_type_from_target(target); end
  def resolve_scope_type(target); end
  def self.included(base); end
  include ActionPolicy::Behaviours::Scoping
end
module ActionPolicy::Policy::Scoping::ClassMethods
  def scope_for(type, name = nil, &block); end
  def scope_matcher(type, class_or_proc); end
  def scope_matchers; end
  def scoping_handlers; end
end
module ActionPolicy::Policy::Cache
  def apply(rule); end
  def apply_with_cache(rule); end
  def cache(*parts, **options); end
  def cache_key(*parts); end
  def cache_namespace; end
  def context_cache_key; end
  def rule_cache_key(rule); end
  def self.included(base); end
end
module ActionPolicy::Policy::Cache::ClassMethods
  def cache(*rules, **options); end
  def cached_rules; end
end
module ActionPolicy::Policy::CachedApply
  def apply(rule); end
end
class ActionPolicy::Base
  extend ActionPolicy::Policy::Aliases::ClassMethods
  extend ActionPolicy::Policy::Authorization::ClassMethods
  extend ActionPolicy::Policy::Cache::ClassMethods
  extend ActionPolicy::Policy::Core::ClassMethods
  extend ActionPolicy::Policy::PreCheck::ClassMethods
  extend ActionPolicy::Policy::Scoping::ClassMethods
  extend ActionPolicy::ScopeMatchers::ActionControllerParams
  extend ActionPolicy::ScopeMatchers::ActiveRecord
  include ActionPolicy::Policy::Aliases
  include ActionPolicy::Policy::Authorization
  include ActionPolicy::Policy::Cache
  include ActionPolicy::Policy::CachedApply
  include ActionPolicy::Policy::Core
  include ActionPolicy::Policy::Defaults
  include ActionPolicy::Policy::PreCheck
  include ActionPolicy::Policy::Reasons
  include ActionPolicy::Policy::Scoping
end
class ActionPolicy::Base::APR < ActionPolicy::Policy::ExecutionResult
end
module ActionPolicy::Ext::SymbolCamelize
end
module ActionPolicy::Ext::ModuleNamespace
end
module ActionPolicy::Ext::ModuleNamespace::Ext
  def namespace; end
end
module ActionPolicy::LookupChain
  def self.call(record, **opts); end
  def self.chain; end
  def self.chain=(arg0); end
  def self.lookup_within_namespace(policy_name, namespace, strict: nil); end
  def self.namespace_cache_enabled; end
  def self.namespace_cache_enabled=(arg0); end
  def self.namespace_cache_enabled?; end
  def self.policy_class_name_for(record); end
end
class ActionPolicy::LookupChain::NamespaceCache
  def self.clear; end
  def self.fetch(namespace, policy, strict:, &block); end
  def self.put_if_absent(scope, namespace, policy); end
  def self.store; end
end
module ActionPolicy::Behaviours::Memoized
  def __policies_cache__; end
  def __policy_memoize__(record, **options); end
  def self.included(base); end
  def self.prepended(base); end
end
module ActionPolicy::Behaviours::Memoized::InstanceMethods
  def policy_for(record:, **opts); end
end
module ActionPolicy::PerThreadCache
  def self.clear_all; end
  def self.enabled=(arg0); end
  def self.enabled?; end
  def self.fetch(key); end
end
module ActionPolicy::Behaviours::ThreadMemoized
  def __policy_thread_memoize__(record, **options); end
  def self.included(base); end
  def self.prepended(base); end
end
module ActionPolicy::Behaviours::ThreadMemoized::InstanceMethods
  def policy_for(record:, **opts); end
end
module ActionPolicy::Behaviours::Namespaced
  def self.included(base); end
  def self.prepended(base); end
end
module ActionPolicy::Behaviours::Namespaced::InstanceMethods
  def authorization_namespace; end
end
class ActionPolicy::Unauthorized < ActionPolicy::Error
  def initialize(policy, rule); end
  def policy; end
  def result; end
  def rule; end
end
module ActionPolicy::Authorizer
  def self.authorize(policy, rule); end
  def self.call(policy, rule); end
  def self.scopify(target, policy, **options); end
end
module ActionPolicy::Behaviour
  def allowance_to(rule, record = nil, **options); end
  def allowed_to?(rule, record = nil, **options); end
  def authorization_context; end
  def authorization_rule_for(policy, rule); end
  def authorize!(record = nil, to:, **options); end
  def lookup_authorization_policy(record, **options); end
  def self.included(base); end
  include ActionPolicy::Behaviours::PolicyFor
  include ActionPolicy::Behaviours::Scoping
end
module ActionPolicy::Behaviour::ClassMethods
  def authorization_targets; end
  def authorize(key, through: nil); end
end
module ActionPolicy::I18n
  def self.candidates_for(policy_class, rule); end
  def self.full_message(policy_class, rule, details = nil); end
end
class ActionPolicy::UnauthorizedAction < ActionPolicy::Error
  def initialize(controller, action); end
end
module ActionPolicy::Controller
  def authorize!(record = nil, to: nil, **options); end
  def authorize_count; end
  def implicit_authorization_target; end
  def skip_verify_authorized!; end
  def verify_authorized; end
  extend ActiveSupport::Concern
  include ActionPolicy::Behaviour
  include ActionPolicy::Behaviours::Memoized
  include ActionPolicy::Behaviours::Namespaced
  include ActionPolicy::Behaviours::ThreadMemoized
end
module ActionPolicy::Controller::ClassMethods
  def skip_verify_authorized(**options); end
  def verify_authorized(**options); end
  include ActionPolicy::Behaviour::ClassMethods
end
module ActionPolicy::Channel
  extend ActiveSupport::Concern
  include ActionPolicy::Behaviour
  include ActionPolicy::Behaviours::Namespaced
end
module ActionPolicy::Channel::ClassMethods
  include ActionPolicy::Behaviour::ClassMethods
end
class ActionPolicy::Railtie < Rails::Railtie
end
module ActionPolicy::Railtie::Config
  def self.auto_inject_into_channel; end
  def self.auto_inject_into_channel=(arg0); end
  def self.auto_inject_into_controller; end
  def self.auto_inject_into_controller=(arg0); end
  def self.cache_store=(store); end
  def self.channel_authorize_current_user; end
  def self.channel_authorize_current_user=(arg0); end
  def self.controller_authorize_current_user; end
  def self.controller_authorize_current_user=(arg0); end
  def self.instrumentation_enabled; end
  def self.instrumentation_enabled=(arg0); end
  def self.namespace_cache_enabled; end
  def self.namespace_cache_enabled=(arg0); end
end
class ActionPolicy::Error < StandardError
end
class ActionPolicy::NotFound < ActionPolicy::Error
  def initialize(target, message = nil); end
  def message; end
  def target; end
end
module Anonymous_Module_45
end
class ActiveRecord::Relation
  include Anonymous_Module_45
  include Anonymous_Module_46
end
module ActionPolicy::ScopeMatchers
end
module ActionPolicy::ScopeMatchers::ActiveRecord
end
module Anonymous_Module_46
end
module ActionPolicy::Policy::Rails
end
module ActionPolicy::Policy::Rails::Instrumentation
end
module ActionPolicy::Rails
end
module ActionPolicy::Rails::Authorizer
end
module ActionPolicy::ScopeMatchers::ActionControllerParams
end
